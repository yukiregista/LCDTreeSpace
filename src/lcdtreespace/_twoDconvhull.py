import numpy as np
from ._utils import *
from scipy.optimize import linprog
from ._geodesic_sample import geodesic_sample
from numpy import argmax, tile, where, arange
from scipy.sparse import csr_matrix
from numpy.linalg import inv
from ._link_convhull import _link_convex_hull
from itertools import combinations


def _twoDconvhull(sample_coord1, sample_coord2, sample_angle, start_index,
                    sample_bd_coord, sample_bd_lam, edge_indices):
    #solves the two dimensional convex hull
    # INPUT
    ## sample_coord1, sample_coord2: 1dim ndarray of length of sample size
    ## sample_angle: 1dim ndarray of length of sample size
    ## start_index: ndarray of size 27, generated by get_start_indices()
    ## sample_bd_coord: list of length 10, each element is ndarray of coordinates.
    ### Output of geodesic_sample
    ## sample_bd_lam : list of length 10, each element is csr_matrix of lams
    ### each row represents boundary points, each column represents sample points.
    ### output of geodesic_sample (LAMS)
    ## edge_indices : indices of boundaries in the convex hull.
    ### Output of link_convex_hull
    #
    # OUTPUT
    ## ext_coord: list of length 10, each element containing either None (for nonincluded boundaries) or the coordinate of extreme value.
    ## ext_lam : list of length 10, each element containing either None (for nonincluded boundaries) or the lams of extreme value.
    ## simple_indicator : list of length 10, each element containing either None (for nonincluded boundaries) or
    ### 0 for nonsimple boundary (generated by other boundary) and 1 for simple boundary (generated by samples)
    cells = tuple_2dcells()

    n = len(sample_coord1)

    n_edge = len(edge_indices)

    edge_ind_to_var_ind = dict(zip(edge_indices, [i for i in range(n_edge)]))

    c = np.zeros(n_edge)
    c.fill(-1) # LP coefficients

    ## adding constraints
    ### constraints of the first type
    ub_arr = np.zeros(n_edge + 6*n)
    A_ub = np.zeros((n_edge + 6*n, n_edge))
    max_ind_list = []
    H_y = np.zeros(n_edge + 6*n)
    H_sample_index = np.zeros(n_edge + 6 * n, dtype=np.int64)
    counter = 0
    firsttype_index_to_varind = []
    for i in range(len(edge_indices)):
        ind = edge_indices[i]
        if len(sample_bd_coord[ind]) == 0:
            continue
        i_x_max_ind = argmax(sample_bd_coord[ind])
        max_ind_list.append(i_x_max_ind)
        ub_arr[counter] = 1/sample_bd_coord[ind][i_x_max_ind]
        A_ub[counter, i] = 1
        firsttype_index_to_varind.append(i)
        counter+=1

    n_firsttype = counter
    #counter = n_edge
    ### constraints of the second type
    for i in range(15):
        p_edge, q_edge = cells[i]
        i_start = start_index[i]
        i_end = start_index[i+1]
        i_aranged = arange(i_start, i_end)
        const_start = 6 * start_index[i] + n_edge
        if (i_end==i_start):continue;
        num_i = i_end-i_start
        p_i = sample_coord1[i_start:i_end]
        q_i = sample_coord2[i_start:i_end]

        if p_edge in edge_ind_to_var_ind:
            p_varind = edge_ind_to_var_ind[p_edge]
            p_neighbor = find_neighbors(p_edge)
            p_neighbor.remove(q_edge)
            p_neighbor_varind = [edge_ind_to_var_ind[item] for item in p_neighbor if item in edge_ind_to_var_ind]
            n_p_neighbor = len(p_neighbor_varind)
            if n_p_neighbor:
                tmp = counter + num_i * n_p_neighbor
                ub_arr[counter:tmp] = tile(1/p_i, n_p_neighbor)
                A_ub[counter:tmp, p_varind].fill(1)
                H_y[counter:tmp] = tile(q_i, n_p_neighbor)
                H_sample_index[counter:tmp] = tile(i_aranged, n_p_neighbor)
                for k in range(n_p_neighbor):
                    A_ub[counter:counter+num_i, p_neighbor_varind[k]] = -q_i/p_i
                    counter += num_i
                # counter is already renewed at this point        
        if q_edge in edge_ind_to_var_ind:
            q_varind = edge_ind_to_var_ind[q_edge]
            q_neighbor = find_neighbors(q_edge)
            q_neighbor.remove(p_edge)
            q_neighbor_varind = [edge_ind_to_var_ind[item] for item in q_neighbor if item in edge_ind_to_var_ind]
            n_q_neighbor = len(q_neighbor_varind)
            if n_q_neighbor:
                tmp = counter + num_i * n_q_neighbor
                ub_arr[counter:tmp] = tile(1/q_i, n_q_neighbor)
                A_ub[counter:tmp, q_varind].fill(1)
                H_y[counter:tmp] = tile(p_i, n_q_neighbor)
                H_sample_index[counter:tmp] = tile(i_aranged, n_q_neighbor)
                for k in range(n_q_neighbor):
                    A_ub[counter:counter+num_i, q_neighbor_varind[k]] = -p_i/q_i
                    counter += num_i
    A_ub = A_ub[:counter]
    ub_arr = ub_arr[:counter]

    res = linprog(c, A_ub = A_ub, b_ub = ub_arr, method="highs")

    active_constraints = where(res.slack == 0)[0]
    if len(active_constraints) != n_edge:
        if len(active_constraints) > n_edge:
            for item in combinations([i for i in range(len(active_constraints))], n_edge):
                ok = False
                rank = np.linalg.matrix_rank(A_ub[active_constraints[list(item)]])
                if rank == n_edge:
                    active_constraints = active_constraints[list(item)]
                    ok = True
                    break
            if ok is False:
                raise Exception("ERROR in twoDconvhull: the number of active constraints doesn't match number of variables.")
        else:
            raise Exception("ERROR in twoDconvhull: the number of active constraints doesn't match number of variables.")
        '''
        pattern = 0
        count = 0
        A = np.zeros((n_edge, n_edge))
        dbdy = np.zeros((n_edge, n))
        simple_indicator = [None]*10
        while count < len(active_constraints):
            index = active_constraints[count]
            if index<n_edge:
                ind = edge_indices[index]
                #A[count] = sample_bd_lam[ind].getrow(max_ind_list[index]).toarray()
                A[count, index] = 1
                dbdy[count] = sample_bd_lam[ind].getrow(max_ind_list[index]).toarray()
                simple_indicator[ind] = 1
            else:
                break
            count += 1
        while count < len(active_constraints):
            main_varind = where(A_ub[active_constraints[count]] > 0)[0][0]
            sub_varind = where(A_ub[active_constraints[count]] < 0)[0][0]
            A[count, main_varind] = 1
            A[count, sub_varind] = -H_y[active_constraints[count]]/(H_y[active_constraints[count]] + 1/res.x[sub_varind])
            dbdy[count, H_sample_index[active_constraints[count]]] = (1/res.x[sub_varind])/(H_y[active_constraints[count]] + 1/res.x[sub_varind])
            simple_indicator[main_varind] = 0
            count += 1
        print(A); input()
        print(res.slack); input()
        print(res.con); input()
        '''

    pattern = 0
    count = 0
    A = np.zeros((n_edge, n_edge))
    dbdy = np.zeros((n_edge, n))
    simple_indicator = [None]*10
    while count < n_edge:
        index = active_constraints[count]
        if index<n_firsttype:
            ind = edge_indices[firsttype_index_to_varind[index]]
            #ind = edge_indices[index]
            #A[count] = sample_bd_lam[ind].getrow(max_ind_list[index]).toarray()
            #A[count, index] = 1
            A[count, firsttype_index_to_varind[index]] = 1
            dbdy[count] = sample_bd_lam[ind].getrow(max_ind_list[index]).toarray()
            simple_indicator[ind] = 1
        else:
            break
        count += 1
    while count < n_edge:
        main_varind = where(A_ub[active_constraints[count]] > 0)[0][0]
        sub_varind = where(A_ub[active_constraints[count]] < 0)[0][0]
        A[count, main_varind] = 1
        A[count, sub_varind] = -H_y[active_constraints[count]]/(H_y[active_constraints[count]] + 1/res.x[sub_varind])
        dbdy[count, H_sample_index[active_constraints[count]]] = (1/res.x[sub_varind])/(H_y[active_constraints[count]] + 1/res.x[sub_varind])
        simple_indicator[main_varind] = 0
        count += 1
        #A[count, active_constraints[count]] = 1
    EXT_LAM = inv(A) @ dbdy
    ext_coord = [None] * 10
    ext_lam = [None]*10
    for i in range(n_edge):
        ext_coord[edge_indices[i]] = 1/res.x[i]
        ext_lam[edge_indices[i]] = csr_matrix(EXT_LAM[i])

    return ext_coord, ext_lam, simple_indicator





if __name__ == "__main__":
    X = pd.read_csv("../data/sample_data_100_case4.csv")
    #X = pd.read_csv("../data/case3/testcase_100_2.csv")
    sort_ind = argsort_by_orthants(X)
    X = X.iloc[sort_ind]

    # prepare arguments
    sample_coord1 = X['x1'].values
    sample_coord2 = X['x2'].values
    sample_angle = X['angle'].values
    start_index = get_start_indices(X)
    cells = tuple_2dcells()
    orthants = tuple_orthants()

    sample_bd_coord, sample_bd_lam, sample_origin_lam = geodesic_sample(sample_coord1, sample_coord2, sample_angle,start_index, cells)
    edge_indices = _link_convex_hull(sample_angle, start_index)
    ext_coord, ext_lam, simple_indicator = _twoDconvhull(sample_coord1, sample_coord2, sample_angle, start_index,
                        sample_bd_coord, sample_bd_lam, edge_indices)
