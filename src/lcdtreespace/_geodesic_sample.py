import numpy as np
from numpy import ravel, argmin, tile, repeat, array, arange, where, sqrt
from numpy import meshgrid
from ._utils import *
from scipy.sparse import csr_matrix

def geodesic_sample(sample_coord1, sample_coord2, sample_angle, start_index, cells):
    # Take geodesics between top-dim orthants vs top-dim orthants
    #
    # INPUTS
    ## sample_coord1, sample_coord2: 1dim ndarray of length of sample size
    ## sample_angle: 1dim ndarray of length of sample size
    ## start_index: ndarray of size 27, generated by get_start_indices()
    ## cells: list of 2d cells represented by tuple of two edges
    #
    # OUTPUTS
    ## bd_coords: list of length 10.
    ### Element i contains coordinates of points in the boundary i generated by geodesics between sample points (1dim ndarray)
    ## LAMS: list of length 10.
    ### Element i contains csr_matrix of dimension 2.
    ### (j,k) element of this matrix contains contribution(lam) of sample k to the construction of boundary point j
    ## ORIGIN_LAM: csr_matrix, similary to each element of LAMS
    n = len(sample_coord1)
    lenmat = b_to_b_lenmat()
    lams = [np.zeros(n**2) for i in range(10)]
    bd_coords = [np.zeros(n**2) for i in range(10)]
    lam_col1 = [np.zeros(n**2, dtype=np.int64) for i in range(10)]
    lam_col2 = [np.zeros(n**2, dtype=np.int64) for i in range(10)]
    origin_lams = np.zeros((n**2)//2)
    origin_col1 = np.zeros((n**2)//2, dtype=np.int64)
    origin_col2 = np.zeros((n**2)//2, dtype=np.int64)
    counters = [0] * 10
    origin_counter = 0
    PI = np.pi
    PI_2 = np.pi/2
    for i in range(15):
        cell_i = cells[i]
        i_start = start_index[i]
        i_end = start_index[i+1]
        if (i_end==i_start):continue;
        num_i = i_end-i_start
        i_aranged = arange(i_start, i_end)
        i_angle = sample_angle[i_start:i_end]
        for j in range(i+1, 15):
            cell_j = cells[j]
            j_start = start_index[j]
            j_end = start_index[j+1]
            if (j_end==j_start):continue;
            num_j = j_end-j_start
            num_ij = num_i * num_j
            dist_ij = array([lenmat[cell_i[0], cell_j[0]], lenmat[cell_i[0], cell_j[1]],
                        lenmat[cell_i[1], cell_j[0]],lenmat[cell_i[1], cell_j[1]]], dtype=np.int8)
            index_min = argmin(dist_ij)
            n_ort_btwn = dist_ij[index_min]
            l, r = index_min//2, index_min % 2
            if n_ort_btwn==0:
                bd_index = cell_i[l]
                if l: #if l==1
                    x_i = sample_coord1[i_start:i_end];
                    y_i = sample_coord2[i_start:i_end]; ## y is the shared coordinate
                else:
                    x_i = sample_coord2[i_start:i_end];
                    y_i = sample_coord1[i_start:i_end]; ## y is the shared coordinate
                if r: ## if r==1
                    x_j = sample_coord1[j_start:j_end];
                    y_j = sample_coord2[j_start:j_end]; ## y is the shared coordinate
                else:
                    x_j = sample_coord2[j_start:j_end];
                    y_j = sample_coord1[j_start:j_end]; ## y is the shared coordinate
                counter = counters[bd_index]
                i_coef = tile(x_j,num_i)/ravel(x_i.reshape(-1,1) + x_j)
                lams[bd_index][counter:counter + num_ij] = i_coef
                bd_coords[bd_index][counter:counter + num_ij] = i_coef * repeat(y_i, num_j) + (1-i_coef) * tile(y_j, num_i)
                lam_col1[bd_index][counter:counter + num_ij] = repeat(i_aranged, num_j)
                lam_col2[bd_index][counter:counter + num_ij] = tile(arange(j_start, j_end), num_i)
                counters[bd_index] += num_ij
                ## having same edge
            elif n_ort_btwn == 1:
                bd1_index = cell_i[l]
                bd2_index = cell_j[r]
                if l: #if l==1
                    x_i = sample_coord1[i_start:i_end];
                    y_i = sample_coord2[i_start:i_end]; ## y is the closest coordinate
                    i_angle_to_closest_edge = PI_2 - i_angle
                else:
                    x_i = sample_coord2[i_start:i_end];
                    y_i = sample_coord1[i_start:i_end]; ## y is the closest coordinate
                    i_angle_to_closest_edge = i_angle
                if r: ## if r==1
                    x_j = sample_coord2[j_start:j_end]; ## x is the closest coordinate
                    y_j = sample_coord1[j_start:j_end];
                    j_angle_to_closest_edge = PI_2 - sample_angle[j_start:j_end]
                else:
                    x_j = sample_coord1[j_start:j_end];
                    y_j = sample_coord2[j_start:j_end]; ## x is the closest coordinate
                    j_angle_to_closest_edge = sample_angle[j_start:j_end]
                ij_angle = i_angle_to_closest_edge.reshape(-1,1) + j_angle_to_closest_edge
                x_i_coef = x_j/(x_i.reshape(-1,1) + x_j)
                y_i_coef = y_j/(y_i.reshape(-1,1) + y_j)
                not_cone_path_row, not_cone_path_col = where(ij_angle < PI_2)
                len_ncpr = len(not_cone_path_row)
                j_aranged = arange(j_start, j_end)
                if len_ncpr > 0:
                    x_i_coef2 = ravel(x_i_coef[not_cone_path_row, not_cone_path_col])
                    y_i_coef2 = ravel(y_i_coef[not_cone_path_row, not_cone_path_col])

                    counter = counters[bd1_index]
                    tmp = counter + len_ncpr
                    #print(x_i[not_cone_path_row][0], y_i[not_cone_path_row][0])
                    #print(x_j[not_cone_path_col][0], y_j[not_cone_path_col][0])
                    lams[bd1_index][counter:tmp] = x_i_coef2
                    bd_coords[bd1_index][counter:tmp] = x_i_coef2 * y_i[not_cone_path_row] + (1-x_i_coef2) * (-y_j[not_cone_path_col])
                    lam_col1[bd1_index][counter:tmp] = i_aranged[not_cone_path_row]
                    lam_col2[bd1_index][counter:tmp] = j_aranged[not_cone_path_col]
                    counters[bd1_index] = tmp;


                    counter = counters[bd2_index]; tmp = counter + len_ncpr
                    lams[bd2_index][counter:tmp] = y_i_coef2
                    bd_coords[bd2_index][counter:tmp] = y_i_coef2 * (-x_i[not_cone_path_row]) + (1-y_i_coef2) * x_j[not_cone_path_col]
                    lam_col1[bd2_index][counter:tmp] = i_aranged[not_cone_path_row]
                    lam_col2[bd2_index][counter:tmp] = j_aranged[not_cone_path_col]
                    counters[bd2_index] = tmp

                cone_path_row, cone_path_col = where(ij_angle >= PI_2)
                len_cpr = len(cone_path_row)
                if len_cpr > 0:
                    norm_i = sqrt(x_i[cone_path_row]**2 + y_i[cone_path_row]**2)
                    norm_j = sqrt(x_j[cone_path_col]**2 + y_j[cone_path_col]**2)
                    tmp = origin_counter + len_cpr
                    origin_lams[origin_counter:tmp] = norm_j / (norm_i + norm_j)
                    origin_col1[origin_counter:tmp] = i_aranged[cone_path_row]
                    origin_col2[origin_counter:tmp] = j_aranged[cone_path_col]
                    origin_counter = tmp
            elif n_ort_btwn == 2:
                norm_i = sqrt(sample_coord1[i_start:i_end]**2 + sample_coord2[i_start:i_end]**2)
                norm_j = sqrt(sample_coord2[j_start:j_end]**2 + sample_coord1[j_start:j_end]**2)
                tmp = origin_counter + num_ij
                origin_lams[origin_counter:tmp] = ravel(norm_j / (norm_i.reshape(-1,1) + norm_j))
                origin_col1[origin_counter:tmp] = repeat(i_aranged, num_j)
                origin_col2[origin_counter:tmp] = tile(arange(j_start, j_end), num_i)
                origin_counter = tmp


    bd_coords = [bd_coords[i][:counters[i]] for i in range(10)]
    lams = [lams[i][:counters[i]] for i in range(10)]
    lams2 = [1-lams[i] for i in range(10)]
    rows = [tile(arange(0,counters[i]),2) for i in range(10)]
    LAMS = [csr_matrix((np.append(lams[i], lams2[i]), (rows[i], np.append(lam_col1[i][:counters[i]], lam_col2[i][:counters[i]]))), shape = (counters[i], n)) for i in range(10)] # this construction might be slow

    origin_lams = origin_lams[:origin_counter]
    origin_lams2 = 1 - origin_lams
    rows = tile(arange(0,origin_counter),2)
    ORIGIN_LAM = csr_matrix((np.append(origin_lams, origin_lams2), (rows, np.append(origin_col1[:origin_counter], origin_col2[:origin_counter]))),shape = (origin_counter, n)) # this construction might be slow

    return bd_coords, LAMS, ORIGIN_LAM




if __name__ == "__main__":
    #X = pd.read_csv("../data/sample_data_100_case3.csv")
    X = pd.read_csv("../data/sample_data_1000_case4.csv")
    sort_ind = argsort_by_orthants(X)
    X = X.iloc[sort_ind]

    # prepare arguments
    sample_coord1 = X['x1'].values
    sample_coord2 = X['x2'].values
    sample_angle = X['angle'].values
    start_index = get_start_indices(X)
    cells = tuple_2dcells()
    orthants = tuple_orthants()

    sample_bd_coords, sample_bd_lam, sample_origin_lam = geodesic_sample(sample_coord1, sample_coord2, sample_angle,start_index, cells)
    for i in range(10):
        print(sample_bd_coords[i])
        input()
    #print(sample_origin_lam)
